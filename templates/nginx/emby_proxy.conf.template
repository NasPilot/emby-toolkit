# /etc/nginx/conf.d/emby_proxy.conf (V4 - .strm 精准捕获最终版)

upstream emby_server {
    server {{ EMBY_UPSTREAM }};
}

upstream virtual_library_proxy {
    server {{ PROXY_UPSTREAM }};
}

{% if REDIRECT_UPSTREAM %}
upstream redirect_service {
    server {{ REDIRECT_UPSTREAM }};
}
{% endif %}

server {
    listen {{ NGINX_LISTEN_PORT }};
    server_name your.domain.com;

    # --- 基础代理参数 ---
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "Upgrade";
    proxy_buffering off;

    # ====================================================================
    #  核心路由规则 (V4)
    # ====================================================================

    # ★★★ 规则 1：拦截并转发 .strm 请求的302重定向 ★★★
    {% if REDIRECT_UPSTREAM %}
    location ~ \.strm$ {
        proxy_pass http://redirect_service;
        proxy_intercept_errors on;
        
        # ▼▼▼ 核心修改 1/2：强制Nginx传递上游的 'Location' 头 ▼▼▼
        # 默认情况下，Nginx可能会在错误处理跳转时丢弃某些头信息。
        # 这条指令明确告诉Nginx：“把上游返回的 Location 头给我留着！”
        proxy_pass_header Location;

        error_page 302 = @handle_redirect;
    }
    {% endif %}

    location @handle_redirect {
        # ▼▼▼ 核心修改 2/2：使用更可靠的变量 $sent_http_location ▼▼▼
        # $upstream_http_location 依赖于Nginx内部模块的状态，可能为空。
        # 而 $sent_http_location 变量代表“即将发送给客户端的响应头中的Location值”。
        # 结合上面的 proxy_pass_header 指令，这个变量现在一定会有正确的值。
        return 302 $sent_http_location;
    }

    # --- 以下是虚拟库路由规则 ---

    location ~ /emby/Users/([a-f0-9]+)/Views {
        proxy_pass http://virtual_library_proxy;
    }

    # ★★★ 规则 2：【新增的关键规则】拦截“获取库内容”的请求 ★★★
    # 这是我们之前一直缺失的规则！
    location ~ /emby/Users/([a-f0-9]+)/Items$ {
        # 检查 URL 参数中是否包含 ParentId=-xxxxx
        if ($arg_ParentId ~ ^-\d+$) {
            # 如果是，就转发给 Python 代理
            proxy_pass http://virtual_library_proxy;
        }
        # 如果不是，就执行默认行为，转发给真实 Emby
        proxy_pass http://emby_server;
    }

    # 规则 3：拦截所有路径中包含虚拟ID的请求 (例如获取图片)
    location ~ /(emby/Users/[^/]+/Items|emby/Items)/-(\d+) {
        proxy_pass http://virtual_library_proxy;
    }

    # 规则 4：拦截虚拟库内的“元数据筛选”和“最新添加”请求
    location ~ /Items/(Prefixes|Genres|Studios|Tags|OfficialRatings|Years|Latest)$ {
        if ($arg_ParentId ~ ^-\d+$) {
            proxy_pass http://virtual_library_proxy;
        }
        if ($arg_customViewId ~ ^-\d+$) {
            proxy_pass http://virtual_library_proxy;
        }
        proxy_pass http://emby_server;
    }

    # 规则 5: WebSocket (保持不变)
    location /embywebsocket {
        proxy_pass http://emby_server;
    }

    # 这个规则专门捕获播放器试图让服务器代理播放外部URL的行为
    location /emby/Videos/ActiveEncodings {
        # 检查请求的URL参数中是否存在名为 'Url' 的参数
        if ($arg_Url) {
            # 如果存在，直接将客户端302重定向到这个Url参数的值
            # 这就强制让播放器自己去访问那个公网直链
            return 302 $arg_Url;
        }

        # 如果请求中没有 'Url' 参数，说明是正常的内部播放请求，
        # 那么就正常地将它代理给真实的 Emby 服务器。
        proxy_pass http://emby_server;
    }

    # 兜底规则：转发所有其他请求到真实 Emby
    location / {
        proxy_pass http://emby_server;
    }
}